/*
 * Copyright (C) 2016  (See AUTHORS)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

buildscript {
    repositories {
        flatDir dirs: 'lib/', name: 'proguard.jar'
    }
    dependencies {
        classpath ':proguard:'
    }
}

plugins {
    // https://github.com/tbroyer/gradle-apt-plugin
    // https://plugins.gradle.org/plugin/net.ltgt.apt
    id 'net.ltgt.apt-idea' version '0.15'
    // https://github.com/tbroyer/gradle-errorprone-javacplugin-plugin
    // https://plugins.gradle.org/plugin/net.ltgt.errorprone-javacplugin
    id 'net.ltgt.errorprone-javacplugin' version '0.2'
}

// Languages
apply plugin: 'antlr'
apply plugin: 'c'
apply plugin: 'cpp'
apply plugin: 'java'

// Static Analysis
apply plugin: 'pmd'
apply plugin: 'checkstyle'

// IDE Support
apply plugin: 'idea'
apply plugin: 'application'

project.group = 'de.tum.in'
project.version = '18.06-snapshot'

project.sourceCompatibility = JavaVersion.VERSION_1_10
project.targetCompatibility = JavaVersion.VERSION_1_10
project.archivesBaseName = 'owl'

mainClassName = "owl.run.DefaultCli"
def minimize = !project.hasProperty("full")
def buildNatives = !project.hasProperty("disable-native")
def enableProGuard = !project.hasProperty("disable-proguard")

def defaultEncoding = 'UTF-8'
//noinspection GroovyAssignabilityCheck
tasks.withType(JavaCompile) { options.encoding = defaultEncoding }
//noinspection GroovyAssignabilityCheck
tasks.withType(Javadoc) { options.encoding = defaultEncoding }

repositories {
    mavenCentral()
}

dependencies {
    // https://immutables.github.io/
    compileOnly 'org.immutables:value:2.5.6:annotations'

    compile 'com.google.guava:guava:25.0-jre' // https://mvnrepository.com/artifact/com.google.guava/guava/latest
    compile 'it.unimi.dsi:fastutil:8.1.1'
    compile 'org.antlr:antlr4-runtime:4.7.1' // https://mvnrepository.com/artifact/org.antlr/antlr4-runtime/latest
    compile 'de.tum.in:jbdd:0.3.2'
    compile 'de.tum.in:naturals-util:0.10.0'
    compile 'commons-cli:commons-cli:1.4'
    compile files('lib/jhoafparser-1.1.1-patched.jar')

    testCompileOnly 'org.immutables:value:2.5.5:annotations'

    testCompile 'junit:junit:4+'
    testCompile 'org.hamcrest:hamcrest-library:1.3'

    antlr 'org.antlr:antlr4:4.7.1' // Introduces unused runtime dependencies; fixed in antlr.gradle
    annotationProcessor 'org.immutables:value:2.5.6'
    errorprone 'com.google.errorprone:error_prone_core:2.3.1'
}

// Add resources directory for native libraries.
//noinspection GroovyAssignabilityCheck
tasks.withType(Test) {
    systemProperty "java.library.path", "src/main/resources/"
}

apply from: 'gradle/analysis.gradle'
apply from: 'gradle/antlr.gradle'
if (buildNatives)
    apply from: 'gradle/natives.gradle'

jar {
    manifest {
        attributes(
            "Implementation-Title": "owl",
            "Main-Class": project.mainClassName,
            "Implementation-Version": version)
    }
}

//noinspection GroovyAssignabilityCheck
tasks.withType(Javadoc) {
    options.encoding = defaultEncoding
    options.docEncoding = defaultEncoding
    options.charSet = defaultEncoding
    // https://github.com/gradle/gradle/issues/2553 Disables some superfluous warnings of javadoc
    // Generate HTML5
    options.optionFiles << file('config/javadoc.options')
}

//noinspection GroovyAssignabilityCheck,UnnecessaryQualifiedReference
def proGuardTask = task proguard(name: "proguard", type: proguard.gradle.ProGuardTask) {
    if (minimize)
        configuration 'config/proguard-min.txt'
    else
        configuration 'config/proguard.txt'

    libraryjars "${System.getProperty('java.home')}/jmods"
    libraryjars "${System.getProperty('java.home')}/lib"

    dontwarn 'com.oracle.jmc.**'
    dontwarn 'org.immutables.**'
    dontwarn 'afu.org.checkerframework.checker.**'
    dontwarn 'org.checkerframework.checker.**'

    //noinspection GroovyAssignabilityCheck
    injars configurations.findByName('runtimeClasspath').getFiles(), filter: '!META-INF/**,**.class'
    //noinspection GrUnresolvedAccess,GroovyAssignabilityCheck
    injars files(jar)
    outjars new File(project.buildDir, 'libs/owl.jar')
}

// Create startup scripts for each tool
def scripts = [
    'synth'     : 'owl.translations.Synthesis',
    'ltl2da'    : 'owl.translations.LTL2DA',
    'ltl2dpa'   : 'owl.translations.LTL2DPA',
    'ltl2ldba'  : 'owl.translations.ltl2ldba.LTL2LDBACliParser',
    'nba2ldba'  : 'owl.translations.nba2ldba.NBA2LDBA',
    'dra2dpa'   : 'owl.translations.dra2dpa.IARBuilder',
    'delag'     : 'owl.translations.delag.DelagBuilder',
    'ltl2dgra'  : 'owl.translations.rabinizer.RabinizerMain',
    'ltl2dra'   : 'owl.translations.rabinizer.RabinizerDegeneralizeMain',
    'nba2dpa'   : 'owl.translations.nba2dpa.NBA2DPAFunction',
    'owl-server': 'owl.run.ServerCli'
]

ext.createStartScriptTasks = { name, cp, map ->
    map.collect { scriptName, className ->
        tasks.create(name: scriptName + name.capitalize() + 'StartScript',
            type: CreateStartScripts) {
            mainClassName = className
            applicationName = scriptName
            // CreateStartScripts is stupid; it.outputs.files = outputDir, not the created scripts.
            outputDir = new File(project.buildDir, 'scripts/' + scriptName)
            //noinspection GroovyAccessibility
            classpath = cp
        }
    }
}

startScripts.outputDir = new File(project.buildDir, 'scripts/owl')
createStartScriptTasks("", jar.outputs.files + project.configurations.runtime, scripts).each() {
    it.dependsOn(jar)
    startScripts.dependsOn(it)
}

def proGuardStartScripts = createStartScriptTasks("ProGuard", proGuardTask.outputs.files,
    scripts + ['owl': mainClassName])
proGuardStartScripts.each() { it.dependsOn(proGuardTask) }

// Compile the markdown files
tasks.create(name: "compileMarkdown", type: Exec) {
    executable = 'scripts/render-markdown.sh'
    outputs.dir "$project.docsDir/markdown"
    args = ["$project.docsDir/markdown"]
}.onlyIf {
    buildNatives
} // ... if native compilation is enabled (pandoc isn't available everywhere)

// Configure the distribution to include the documentation etc.
distributions {
    // TODO The distribution plugin is stupid: The "main" distribution always contains all runtime
    // dependencies - we can't specify only the minimized jar.
    //noinspection GroovyAssignabilityCheck
    main {
        baseName = 'owl'

        contents {
            into("doc") {
                from "AUTHORS"
                from "LICENSE"
                from compileMarkdown
                from javadoc
            }
            into("src") {
                from "src"
            }
        }
    }
}

if (enableProGuard) {
    distributions.create("small", {
        baseName = 'owl'
        contents {
            into("bin") {
                //noinspection GroovyAssignabilityCheck
                from proGuardStartScripts
            }
            into("lib") {
                from proGuardTask
            }
            if (!minimize) {
                into("doc") {
                    from "AUTHORS"
                    from "LICENSE"
                    from compileMarkdown
                    from javadoc
                }
                into("src") {
                    from "src"
                }
            }
        }
    })
}

// Task to create a minimal running jar
def binTask = tasks.create(name: "buildBin", type: Copy) {
    destinationDir = project.buildDir
    into('bin') {
        // Copy all start-scripts and make them executable
        if (enableProGuard) {
            from(proGuardStartScripts) {
                exclude "*.bat"
            }
        } else {
            from(startScripts) {
                exclude "*.bat"
            }
        }
        fileMode = 0755
    }
    into('lib') {
        if (enableProGuard) {
            from(proGuardTask)
        } else {
            from(jar) // Copy the jar itself
            from([project.configurations.runtime]) // Copy the dependencies
        }
    }
}

if (buildNatives) {
    binTask.dependsOn("owlClientExecutable")
}

// ProGuard dead code detection
//noinspection UnnecessaryQualifiedReference
tasks.create(name: "reportDeadCode", type: proguard.gradle.ProGuardTask) {
    injars files(jar)

    configuration 'config/proguard-deadcode.txt'
    dontwarn '**' // Don't care about missing dependencies - all entry points are here

    // Write usage (or rather lack thereof) into deadcode.txt
    printusage file("$project.buildDir/reports/deadcode.txt")
}.doFirst { file("$project.buildDir/reports").mkdirs() }

apply from: 'gradle/idea.gradle'